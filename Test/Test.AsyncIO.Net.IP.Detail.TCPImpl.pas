unit Test.AsyncIO.Net.IP.Detail.TCPImpl;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, AsyncIO.Net.IP.Detail.TCPImpl, AsyncIO.Net.IP, IdWinsock2, AsyncIO, NetTestCase, EchoTestServer;

type
  // Test methods for class TTCPSocketImpl

  TestTTCPSocketImpl = class(TNetTestCase)
  strict private
    FTestServer: IEchoTestServer;
    FService: IOService;
    FTCPSocketImpl: IPStreamSocket;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetService;
    procedure TestGetProtocol;
    procedure TestGetProtocolIPv4;
    procedure TestGetProtocolIPv6;
    procedure TestGetLocalEndpoint;
    procedure TestGetRemoteEndpoint;
    procedure TestGetSocketHandle;
    procedure TestAsyncConnect;
    procedure TestBind;
    procedure TestConnect;
    procedure TestClose;
    procedure TestShutdown;
    procedure TestAsyncSend;
    procedure TestAsyncReceive;
  end;

implementation

uses
  System.SysUtils, AsyncIO.ErrorCodes;

procedure TestTTCPSocketImpl.SetUp;
begin
  FTestServer := NewEchoTestServer(7);
  FService := NewIOService();
  FTCPSocketImpl := NewTCPSocket(FService);
end;

procedure TestTTCPSocketImpl.TearDown;
begin
  FTCPSocketImpl := nil;
  FService := nil;
  FTestServer := nil;
end;

procedure TestTTCPSocketImpl.TestGetService;
var
  ReturnValue: IOService;
begin
  ReturnValue := FTCPSocketImpl.GetService;
  CheckSame(FService, ReturnValue);
end;

procedure TestTTCPSocketImpl.TestGetSocketHandle;
begin
  // TODO
end;

procedure TestTTCPSocketImpl.TestGetProtocol;
var
  ReturnValue: IPProtocol;
begin
  ReturnValue := FTCPSocketImpl.GetProtocol;

  CheckEquals(IPProtocol.TCP.Unspecified, ReturnValue);
end;

procedure TestTTCPSocketImpl.TestGetProtocolIPv4;
var
  ReturnValue: IPProtocol;
begin
  FTCPSocketImpl.Bind(Endpoint(IPAddressFamily.v4, 0));

  ReturnValue := FTCPSocketImpl.GetProtocol;

  CheckEquals(IPProtocol.TCP.v4, ReturnValue);
end;

procedure TestTTCPSocketImpl.TestGetProtocolIPv6;
var
  ReturnValue: IPProtocol;
begin
  FTCPSocketImpl.Bind(Endpoint(IPAddressFamily.v6, 0));

  ReturnValue := FTCPSocketImpl.GetProtocol;

  CheckEquals(IPProtocol.TCP.v6, ReturnValue);
end;

procedure TestTTCPSocketImpl.TestGetLocalEndpoint;
var
  ReturnValue: IPEndpoint;
begin
  try
    ReturnValue := FTCPSocketImpl.GetLocalEndpoint;
  except
    on E: Exception do CheckIs(E, EOSError, 'Failed to raise OS error for unbound socket');
  end;

  FTCPSocketImpl.Bind(Endpoint(IPv4Address.Loopback, 0));

  ReturnValue := FTCPSocketImpl.GetLocalEndpoint;

  CheckEquals(IPv4Address.Loopback, ReturnValue.Address, 'Failed to get local endpoint');
end;

procedure TestTTCPSocketImpl.TestGetRemoteEndpoint;
var
  PeerEndpoint: IPEndpoint;
  ReturnValue: IPEndpoint;
begin
  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  FTCPSocketImpl.Connect(PeerEndpoint);

  ReturnValue := FTCPSocketImpl.GetRemoteEndpoint;

  CheckEquals(PeerEndpoint, ReturnValue);
end;

procedure TestTTCPSocketImpl.TestAsyncConnect;
var
  Handler: OpHandler;
  PeerEndpoint: IPEndpoint;
  HandlerExecuted: boolean;
begin
  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  HandlerExecuted := False;
  Handler :=
    procedure(const ErrorCode: IOErrorCode)
    begin
      HandlerExecuted := True;
      CheckEquals(IOErrorCode.Success, ErrorCode, 'AsyncConnect failed');
    end;

  FTCPSocketImpl.AsyncConnect(PeerEndpoint, Handler);

  FService.Poll;

  CheckTrue(HandlerExecuted, 'Failed to execute connect handler');
end;

procedure TestTTCPSocketImpl.TestBind;
var
  LocalEndpoint: IPEndpoint;
begin
  LocalEndpoint := Endpoint(IPAddressFamily.v4, 0);

  FTCPSocketImpl.Bind(LocalEndpoint);

  CheckEquals(IPProtocol.TCP.v4, FTCPSocketImpl.GetProtocol);

  StartExpectingException(EOSError);

  LocalEndpoint := Endpoint(IPAddressFamily.v6, 0);

  FTCPSocketImpl.Bind(LocalEndpoint);

  StopExpectingException('Failed to raise error on double-bind');
end;

procedure TestTTCPSocketImpl.TestConnect;
var
  PeerEndpoint: IPEndpoint;
  ReturnValue: IPEndpoint;
begin
  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  FTCPSocketImpl.Connect(PeerEndpoint);

  CheckEquals(PeerEndpoint, FTCPSocketImpl.RemoteEndpoint);

  StartExpectingException(EOSError);

  PeerEndpoint := Endpoint(IPv6Address.Loopback, FTestServer.Port);
  FTCPSocketImpl.Connect(PeerEndpoint);

  StopExpectingException('Failed to raise error on double-connect');
end;

procedure TestTTCPSocketImpl.TestClose;
var
  PeerEndpoint: IPEndpoint;
  ReturnValue: IPEndpoint;
begin
  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  FTCPSocketImpl.Connect(PeerEndpoint);

  FTCPSocketImpl.Close;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);
  FTCPSocketImpl.Connect(PeerEndpoint);

  CheckEquals(PeerEndpoint, FTCPSocketImpl.RemoteEndpoint);
end;

procedure TestTTCPSocketImpl.TestShutdown;
var
  PeerEndpoint: IPEndpoint;
  ShutdownFlag: SocketShutdownFlag;
  Data: TBytes;
  Handler: IOHandler;
  HandlerExecuted: boolean;
begin
  SetLength(Data, 42);

  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  FTCPSocketImpl.Connect(PeerEndpoint);


  FTCPSocketImpl.Shutdown(SocketShutdownWrite);

  HandlerExecuted := False;
  Handler :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      HandlerExecuted := True;
    end;

  try
    FTCPSocketImpl.AsyncSend(Data, Handler);
  except
    on E: Exception do CheckIs(E, EOSError, 'Failed to shutdown write 1');
  end;

  FService.Poll;

  CheckFalse(HandlerExecuted, 'Failed to shutdown write 2');


  FTCPSocketImpl.Shutdown(SocketShutdownRead);

  HandlerExecuted := False;
  Handler :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      HandlerExecuted := True;
    end;


  try
    FTCPSocketImpl.AsyncReceive(Data, Handler);
  except
    on E: Exception do CheckIs(E, EOSError, 'Failed to shutdown read 1');
  end;

  FService.Poll;

  CheckFalse(HandlerExecuted, 'Failed to shutdown read 2');
end;

procedure TestTTCPSocketImpl.TestAsyncSend;
var
  Data: TBytes;
  PeerEndpoint: IPEndpoint;
  Handler: IOHandler;
  Buffer: MemoryBuffer;
  HandlerExecuted: boolean;
begin
  SetLength(Data, 42);

  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  FTCPSocketImpl.Connect(PeerEndpoint);

  HandlerExecuted := False;
  Handler :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      HandlerExecuted := True;
      CheckEquals(IOErrorCode.Success, ErrorCode, 'Failed to write data');
      CheckEquals(Length(Data), BytesTransferred, 'Failed to write all data');
    end;

  FTCPSocketImpl.AsyncSend(Data, Handler);

  FService.RunOne;

  CheckTrue(HandlerExecuted, 'Failed to execute write handler');
end;

procedure TestTTCPSocketImpl.TestAsyncReceive;
var
  SrcData: TBytes;
  RecvData: TBytes;
  PeerEndpoint: IPEndpoint;
  Handler: IOHandler;
  Buffer: MemoryBuffer;
  HandlerExecuted: boolean;
begin
  SrcData := GenerateData(42);

  FTestServer.Start;

  PeerEndpoint := Endpoint(IPv4Address.Loopback, FTestServer.Port);

  FTCPSocketImpl.Connect(PeerEndpoint);

  HandlerExecuted := False;
  Handler :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      HandlerExecuted := True;
      CheckEquals(IOErrorCode.Success, ErrorCode, 'Failed to write data');
      CheckEquals(Length(SrcData), BytesTransferred, 'Failed to write all data');
    end;

  FTCPSocketImpl.AsyncSend(SrcData, Handler);

  FService.RunOne;

  CheckTrue(HandlerExecuted, 'Failed to execute write handler');

  SetLength(RecvData, Length(SrcData));

  // now do actual receive test
  HandlerExecuted := False;
  Handler :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      HandlerExecuted := True;
      CheckEquals(IOErrorCode.Success, ErrorCode, 'Failed to read data');
      CheckEquals(Length(RecvData), BytesTransferred, 'Failed to read all data');
    end;

  FTCPSocketImpl.AsyncReceive(RecvData, Handler);

  FService.RunOne;

  CheckTrue(HandlerExecuted, 'Failed to execute read handler');

  CheckEqualsMem(SrcData, RecvData, Length(SrcData), 'Read data does not match written data');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTTCPSocketImpl.Suite);
end.

