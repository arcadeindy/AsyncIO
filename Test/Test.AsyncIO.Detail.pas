unit Test.AsyncIO.Detail;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, System.Classes, WinAPI.Windows, AsyncIO.Detail, AsyncIO,
  AsyncIO.ErrorCodes;

type
  // Test methods for class IOCPContext

  TestIOCPContext = class(TTestCase)
  strict private
    FIOCPContext: IOCPContext;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestExecHandler;
    procedure TestFromOverlapped;
  end;
  // Test methods for class HandlerContext

  TestHandlerContext = class(TTestCase)
  strict private
    FHandlerContext: HandlerContext;
    FHandlerExecuted: boolean;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestExecHandler;
  end;
  // Test methods for class OpHandlerContext

  TestOpHandlerContext = class(TTestCase)
  strict private
    FOpHandlerContext: OpHandlerContext;
    FHandlerExecuted: boolean;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestExecHandler;
  end;
  // Test methods for class IOHandlerContext

  TestIOHandlerContext = class(TTestCase)
  strict private
    FIOHandlerContext: IOHandlerContext;
    FHandlerExecuted: boolean;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestExecHandler;
  end;
  // Test methods for class IOServiceImpl

  TestIOServiceImpl = class(TTestCase)
  strict private
    FIOService: IOService;
    FHandler1Executed: boolean;
    FHandler2Executed: boolean;
    FHandler3Executed: boolean;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAssociateHandle;
    procedure TestPoll;
    procedure TestPollOne;
    procedure TestRun;
    procedure TestRunOne;
    procedure TestPost;
    procedure TestStop;
  end;
  // Test methods for class AsyncStreamImplBase

  TestAsyncStreamImplBase = class(TTestCase)
  strict private
    FIOService: IOService;
    FAsyncStream: AsyncStream;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetService;
    procedure TestAsyncReadSome;
    procedure TestAsyncWriteSome;
  end;
  // Test methods for class AsyncHandleStreamImpl

  TestAsyncHandleStreamImpl = class(TTestCase)
  strict private
    FHandle: THandle;
    FIOService: IOService;
    FAsyncStream: AsyncStream;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetHandle;
    procedure TestAsyncReadSome;
    procedure TestAsyncWriteSome;
  end;

implementation

uses
  System.SysUtils;

procedure TestIOCPContext.SetUp;
begin
  FIOCPContext := IOCPContext.Create;
end;

procedure TestIOCPContext.TearDown;
begin
  FIOCPContext.Free;
  FIOCPContext := nil;
end;

procedure TestIOCPContext.TestExecHandler;
var
  transferred: Int64;
  ec: IOErrorCode;
begin
  transferred := 0;
  ec := IOErrorCode.Success;

  StartExpectingException(ENotImplemented);

  FIOCPContext.ExecHandler(ec, transferred);

  StopExpectingException();
end;

procedure TestIOCPContext.TestFromOverlapped;
var
  Overlapped: POverlapped;
  ReturnValue: IOCPContext;
begin
  Overlapped := FIOCPContext.Overlapped;

  ReturnValue := FIOCPContext.FromOverlapped(Overlapped);

  CheckSame(FIOCPContext, ReturnValue, 'IOCPContext-Overlapped round-trip failed');
end;

procedure TestHandlerContext.SetUp;
var
  Handler: CompletionHandler;
begin
  Handler :=
    procedure
    begin
      FHandlerExecuted := True;
    end;

  FHandlerContext := HandlerContext.Create(Handler);
  FHandlerExecuted := False;
end;

procedure TestHandlerContext.TearDown;
begin
  FHandlerContext.Free;
  FHandlerContext := nil;
end;

procedure TestHandlerContext.TestExecHandler;
var
  transferred: Int64;
  ec: IOErrorCode;
begin
  transferred := 0;
  ec := IOErrorCode.Success;

  FHandlerContext.ExecHandler(ec, transferred);

  CheckTrue(FHandlerExecuted, 'HandlerContext failed to execute handler');
end;

procedure TestOpHandlerContext.SetUp;
var
  Handler: OpHandler;
begin
  Handler :=
    procedure(const ErrorCode: IOErrorCode)
    begin
      CheckTrue(ErrorCode = IOErrorCode.EndOfFile, 'OpHandler failed to pass ErrorCode parameter correctly');
      FHandlerExecuted := True;
    end;

  FOpHandlerContext := OpHandlerContext.Create(Handler);
  FHandlerExecuted := False;
end;

procedure TestOpHandlerContext.TearDown;
begin
  FOpHandlerContext.Free;
  FOpHandlerContext := nil;
end;

procedure TestOpHandlerContext.TestExecHandler;
var
  transferred: Int64;
  ec: IOErrorCode;
begin
  transferred := 0;
  ec := IOErrorCode.EndOfFile;

  FOpHandlerContext.ExecHandler(ec, transferred);

  CheckTrue(FHandlerExecuted, 'OpHandlerContext failed to execute handler');
end;

procedure TestIOHandlerContext.SetUp;
var
  Handler: IOHandler;
begin
  Handler :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      CheckTrue(ErrorCode = IOErrorCode.EndOfFile, 'IOHandler failed to pass ErrorCode parameter correctly');
      CheckEquals(42, BytesTransferred, 'IOHandler failed to pass BytesTransferred parameter correctly');
      FHandlerExecuted := True;
    end;

  FIOHandlerContext := IOHandlerContext.Create(Handler);
  FHandlerExecuted := False;
end;

procedure TestIOHandlerContext.TearDown;
begin
  FIOHandlerContext.Free;
  FIOHandlerContext := nil;
end;

procedure TestIOHandlerContext.TestExecHandler;
var
  transferred: Int64;
  ec: IOErrorCode;
begin
  transferred := 42;
  ec := IOErrorCode.EndOfFile;

  FIOHandlerContext.ExecHandler(ec, transferred);

  CheckTrue(FHandlerExecuted, 'IOHandlerContext failed to execute handler');
end;

procedure TestIOServiceImpl.SetUp;
begin
  FIOService := IOServiceImpl.Create(0);
  FHandler1Executed := False;
  FHandler2Executed := False;
end;

procedure TestIOServiceImpl.TearDown;
begin
  FIOService := nil;
  DeleteFile('testfile');
end;

procedure TestIOServiceImpl.TestAssociateHandle;
var
  Handle: THandle;
begin
  Handle := INVALID_HANDLE_VALUE;
  try
    Handle := CreateFile('testfile', GENERIC_READ, FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL or FILE_FLAG_OVERLAPPED, 0);

    CheckNotEquals(INVALID_HANDLE_VALUE, Handle, 'Failed to create test file');

    // exception indicates failure
    IOServiceAssociateHandle(FIOService, Handle);
  finally
    CloseHandle(Handle);
  end;

  StartExpectingException(EOSError);

  Handle := INVALID_HANDLE_VALUE;
  IOServiceAssociateHandle(FIOService, Handle);

  StopExpectingException();
end;

procedure TestIOServiceImpl.TestPoll;
var
  Handler1: IOHandler;
  Handler2: IOHandler;
  Ctx: IOCPContext;
  BytesTransferred: System.Cardinal;
  ReturnValue: Int64;
begin
  Handler1 :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      CheckFalse(FHandler1Executed, 'Completion handler 1 executed multiple times');
      FHandler1Executed := True;
      CheckEquals(IOErrorCode.Success.Value, ErrorCode.Value, 'Completion handler 1 received an error');
      CheckEquals(42, BytesTransferred, 'Completion handler 1 received incorrect BytesTransferred value');
    end;

  Handler2 :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      CheckFalse(FHandler2Executed, 'Completion handler 2 executed multiple times');
      FHandler2Executed := True;
      CheckEquals(IOErrorCode.Success.Value, ErrorCode.Value, 'Completion handler 2 received an error');
      CheckEquals(123, BytesTransferred, 'Completion handler 2 received incorrect BytesTransferred value');
    end;

  Ctx := IOHandlerContext.Create(Handler1);
  BytesTransferred := 42;
  IOServicePostCompletion(FIOService, BytesTransferred, Ctx);

  Ctx := IOHandlerContext.Create(Handler2);
  BytesTransferred := 123;
  IOServicePostCompletion(FIOService, BytesTransferred, Ctx);

  ReturnValue := FIOService.Poll;

  CheckEquals(2, ReturnValue, 'Poll returned wrong handler execution count');
  CheckTrue(FHandler1Executed, 'Poll failed to execute handler 1');
  CheckTrue(FHandler2Executed, 'Poll failed to execute handler 2');
end;

procedure TestIOServiceImpl.TestPollOne;
var
  Handler1: IOHandler;
  Handler2: IOHandler;
  Ctx: IOCPContext;
  BytesTransferred: System.Cardinal;
  ReturnValue: Int64;
begin
  Handler1 :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      CheckFalse(FHandler1Executed, 'Completion handler 1 executed multiple times');
      FHandler1Executed := True;
      CheckEquals(IOErrorCode.Success.Value, ErrorCode.Value, 'Completion handler 1 received an error');
      CheckEquals(42, BytesTransferred, 'Completion handler 1 received incorrect BytesTransferred value');
    end;

  Handler2 :=
    procedure(const ErrorCode: IOErrorCode; const BytesTransferred: UInt64)
    begin
      CheckFalse(FHandler2Executed, 'Completion handler 2 executed multiple times');
      FHandler2Executed := True;
      CheckEquals(IOErrorCode.Success.Value, ErrorCode.Value, 'Completion handler 2 received an error');
      CheckEquals(123, BytesTransferred, 'Completion handler 2 received incorrect BytesTransferred value');
    end;

  Ctx := IOHandlerContext.Create(Handler1);
  BytesTransferred := 42;
  IOServicePostCompletion(FIOService, BytesTransferred, Ctx);

  Ctx := IOHandlerContext.Create(Handler2);
  BytesTransferred := 123;
  IOServicePostCompletion(FIOService, BytesTransferred, Ctx);

  ReturnValue := FIOService.PollOne;

  CheckEquals(1, ReturnValue, 'PollOne returned wrong handler execution count');
  CheckTrue(FHandler1Executed, 'PollOne failed to execute handler 1');
  CheckFalse(FHandler2Executed, 'PollOne executed handler 2');
end;

procedure TestIOServiceImpl.TestRun;
var
  ReturnValue: Int64;
begin
//  ReturnValue := FIOService.Run;
  // TODO: Validate method results
end;

procedure TestIOServiceImpl.TestRunOne;
var
  ReturnValue: Int64;
begin
//  ReturnValue := FIOService.RunOne;
  // TODO: Validate method results
end;

procedure TestIOServiceImpl.TestPost;
var
  Handler: CompletionHandler;
  ReturnValue: Int64;
begin
  Handler :=
    procedure
    begin
      CheckFalse(FHandler1Executed, 'Handler executed multiple times');
      FHandler1Executed := True;
    end;

  FIOService.Post(Handler);

  ReturnValue := FIOService.PollOne;

  CheckTrue(FHandler1Executed, 'Failed to execute handler');
  CheckEquals(1, ReturnValue, 'PollOne returned wrong handler execution count');
end;

procedure TestIOServiceImpl.TestStop;
var
  Handler: CompletionHandler;
  ReturnValue: Int64;
begin
  Handler :=
    procedure
    begin
      FHandler1Executed := True;
    end;

  FIOService.Post(Handler);

  FIOService.Stop;

  ReturnValue := FIOService.PollOne;

  CheckFalse(FHandler1Executed, 'Failed to stop handler');
  CheckEquals(0, ReturnValue, 'PollOne returned wrong handler execution count');
end;

procedure TestAsyncStreamImplBase.SetUp;
begin
  FIOService := NewIOService();
  FAsyncStream := AsyncStreamImplBase.Create(FIOService);
end;

procedure TestAsyncStreamImplBase.TearDown;
begin
  FIOService := nil;
  FAsyncStream := nil;
end;

procedure TestAsyncStreamImplBase.TestGetService;
var
  ReturnValue: IOService;
begin
  ReturnValue := FAsyncStream.GetService;

  CheckSame(FIOService, ReturnValue);
end;

procedure TestAsyncStreamImplBase.TestAsyncReadSome;
var
  Handler: IOHandler;
  Buffer: MemoryBuffer;
begin
  Handler := nil;
  Buffer := MakeBuffer(nil, 0);

  StartExpectingException(EAbstractError);

  FAsyncStream.AsyncReadSome(Buffer, Handler);

  StopExpectingException('Implement missing tests');
end;

procedure TestAsyncStreamImplBase.TestAsyncWriteSome;
var
  Handler: IOHandler;
  Buffer: MemoryBuffer;
begin
  Handler := nil;
  Buffer := MakeBuffer(nil, 0);

  StartExpectingException(EAbstractError);

  FAsyncStream.AsyncWriteSome(Buffer, Handler);

  StopExpectingException('Implement missing tests');
end;

procedure TestAsyncHandleStreamImpl.SetUp;
begin
//  FHandle := CreateFile('testfile', GENERIC_READ, FILE_SHARE_READ or FILE_SHARE_WRITE, nil, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
//  if (FHandle = INVALID_HANDLE_VALUE) then
//    RaiseLastOSError;
//
//  FIOService := NewIOService(0);
//  FAsyncStream := AsyncHandleStreamImpl.Create(FIOService, FHandle);
end;

procedure TestAsyncHandleStreamImpl.TearDown;
begin
  // FHandle is closed by AsyncHandleStreamImpl
  FIOService := nil;
  FAsyncStream := nil;
//  DeleteFile('testfile');
end;

procedure TestAsyncHandleStreamImpl.TestGetHandle;
var
  ReturnValue: THandle;
begin
//  ReturnValue := FAsyncStream.GetHandle;

//  CheckEquals(FHandle, ReturnValue, 'Wrong handle returned by GetHandle');
end;

procedure TestAsyncHandleStreamImpl.TestAsyncReadSome;
var
  Handler: IOHandler;
  Buffer: MemoryBuffer;
begin
//  SetFilePointer(FHandle, 0, 0, FILE_BEGIN);
//
//  WriteFile(FHandle, data, Length(data), bytesWritten, nil);

//  FAsyncStream.AsyncReadSome(Buffer, Handler);
  // TODO: Validate method results
end;

procedure TestAsyncHandleStreamImpl.TestAsyncWriteSome;
var
  Handler: IOHandler;
  Buffer: MemoryBuffer;
begin
  // TODO: Setup method call parameters
//  FAsyncStream.AsyncWriteSome(Buffer, Handler);
  // TODO: Validate method results
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestIOCPContext.Suite);
  RegisterTest(TestHandlerContext.Suite);
  RegisterTest(TestOpHandlerContext.Suite);
  RegisterTest(TestIOHandlerContext.Suite);
  RegisterTest(TestIOServiceImpl.Suite);
  RegisterTest(TestAsyncStreamImplBase.Suite);
  RegisterTest(TestAsyncHandleStreamImpl.Suite);
end.

